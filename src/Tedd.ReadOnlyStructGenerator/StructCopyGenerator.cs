using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Tedd;

[Generator]
public class StructCopyGenerator : ISourceGenerator
{

    public void Initialize(GeneratorInitializationContext context)
    {
        // No initialization is required for this generator.
#if DEBUG
        if (!Debugger.IsAttached)
        {
            //Debugger.Launch();
            for (var i=0; i < 10; i++)
                if (!System.Diagnostics.Debugger.IsAttached)
                    System.Threading.Thread.Sleep(1000);
            //System.Threading.Thread.Sleep(10000);
            //while (!System.Diagnostics.Debugger.IsAttached)
            //System.Threading.Thread.Sleep(5000);
        }
#endif 
        Debug.WriteLine("Initialize code generator");
    }

    public void Execute(GeneratorExecutionContext context)
    {
        var attributeName = "GenerateReadOnlyStruct";
        // Add
        context.AddSource("ReadOnlyGenerator.cs", SourceText.From(@$"// Auto generated by {nameof(StructCopyGenerator)}
namespace Tedd;

[AttributeUsage(AttributeTargets.Struct)]
public class {attributeName}Attribute: Attribute {{ }}", Encoding.ASCII));


        Debug.WriteLine("Execute code generator");
        var log = new StringBuilder();
        //try
        //{

            //// Get all struct declarations that have the ReadOnlyAttribute applied.
            //foreach (var syntaxTree in context.Compilation.SyntaxTrees)
            //{
            //    var root = syntaxTree.GetRoot().DescendantNodes().OfType<StructDeclarationSyntax>();
            //    foreach (var sds in root)
            //    {
            //        foreach (var attributeList in sds.AttributeLists)
            //        {
            //            foreach (var attribute in attributeList.Attributes)
            //            {
            //                if (attribute.Name.ToString() == attributeName)
            //                {
            //                    // Found a struct with the attribute applied.
            //                    // Get the semantic model for the syntax tree.
            //                    var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);




            //                }
            //            }
            //        }
            //    }
            //}
            static string ToLowerFirstChar(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return input;

                return char.ToLower(input[0]) + input.Substring(1);
            }

            var structDeclarations = context.Compilation.SyntaxTrees
                    .SelectMany(syntaxTree => syntaxTree.GetRoot().DescendantNodes().OfType<StructDeclarationSyntax>())
                    .Where(structDeclaration => structDeclaration.AttributeLists
                        .SelectMany(attributeList => attributeList.Attributes)
                        .Any(attribute => attribute.Name.ToString() == attributeName)).ToArray();

            var nsDic = new Dictionary<string, NamespaceDeclarationSyntax>();

            // Create a read-only copy for each struct declaration.
            foreach (var structDeclaration in structDeclarations)
            {
                var structName = structDeclaration.Identifier.Text;
                log.AppendLine("Struct: " + structName);

                // Clone each struct declaration.
                var structCopyDeclaration = structDeclaration
                    .WithIdentifier(SyntaxFactory.Identifier("ReadOnly" + structName))
                    .WithModifiers(structDeclaration.Modifiers.Add(SyntaxFactory.Token(SyntaxKind.ReadOnlyKeyword)))
                    .WithAttributeLists(SyntaxFactory.List<AttributeListSyntax>())
                    // Add ReadOnly attribute
                    .WithMembers(SyntaxFactory.List(
                        structDeclaration.Members.Select(member =>
                        member.AddModifiers(SyntaxFactory.Token(SyntaxKind.ReadOnlyKeyword)))
                    ));


                var fields = structDeclaration.Members.OfType<FieldDeclarationSyntax>().SelectMany(field => field.Declaration.Variables).ToArray();

                // Add a constructor that takes the original struct as a parameter and assigns the fields.
                structCopyDeclaration = structCopyDeclaration.AddMembers(
                    SyntaxFactory.ConstructorDeclaration("ReadOnly" + structName)
                        .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                        .AddParameterListParameters(SyntaxFactory.Parameter(SyntaxFactory.Identifier("value")).WithType(SyntaxFactory.ParseTypeName(structName)))
                        // Add a body to the constructor that assigns the fields.
                        .WithBody(SyntaxFactory.Block(
                            fields.Select(field => SyntaxFactory.ExpressionStatement(
                                    SyntaxFactory.AssignmentExpression(
                                        SyntaxKind.SimpleAssignmentExpression,
                                        SyntaxFactory.IdentifierName(field.Identifier),
                                        SyntaxFactory.MemberAccessExpression(
                                            SyntaxKind.SimpleMemberAccessExpression,
                                            SyntaxFactory.IdentifierName("value"),
                                            SyntaxFactory.IdentifierName(field.Identifier)))))
                                .ToArray())));

                structCopyDeclaration = structCopyDeclaration.AddMembers(
                    SyntaxFactory.ConstructorDeclaration("ReadOnly" + structName)
                        .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                        .AddParameterListParameters(fields.Select(field => SyntaxFactory.Parameter(SyntaxFactory.Identifier(ToLowerFirstChar(field.Identifier.Text))).WithType(SyntaxFactory.ParseTypeName(((VariableDeclarationSyntax)field.Parent).Type.ToString()))).ToArray())
                        // Add a body to the constructor that assigns the fields.
                        .WithBody(SyntaxFactory.Block(
                            fields.Select(field => SyntaxFactory.ExpressionStatement(
                                    SyntaxFactory.AssignmentExpression(
                                        SyntaxKind.SimpleAssignmentExpression,
                                        SyntaxFactory.MemberAccessExpression(
                                            SyntaxKind.SimpleMemberAccessExpression,
                                            SyntaxFactory.IdentifierName("this"),
                                            SyntaxFactory.IdentifierName(field.Identifier)

                                            ),
                                        SyntaxFactory.IdentifierName(ToLowerFirstChar(field.Identifier.Text))
                                        )))
                                .ToArray())));




                // Add the read-only struct to the compilation.
                //Debug.WriteLine(structCopyDeclaration.NormalizeWhitespace().ToFullString());
                //context.AddSource(structName + "ReadOnlyStruct.cs", structCopyDeclaration.NormalizeWhitespace().ToFullString());
                // Add to namespace
                var @namespace = context.Compilation.GetSemanticModel(structDeclaration.SyntaxTree).GetDeclaredSymbol(structDeclaration).ContainingNamespace;
                var ns = @namespace.ToDisplayString();
                if (!nsDic.TryGetValue(ns, out var nsObj))
                    nsDic.Add(ns, nsObj =
                        SyntaxFactory
                            .NamespaceDeclaration(SyntaxFactory.ParseName(@namespace.ToString()))
                            .WithLeadingTrivia(SyntaxFactory.Comment("// This file was generated by the StructCopyGenerator."))
                        );
                nsDic[ns] = nsDic[ns].AddMembers(structCopyDeclaration);


            }

            // Write all the namespaces (with structs) to corresponding files
            foreach (var nskvp in nsDic)
            {
                // Add the read - only struct to the compilation.
                var src = nskvp.Value.NormalizeWhitespace().ToFullString();
                var file = nskvp.Key + ".ReadOnlyStructs.cs";
                Debug.WriteLine("File generated: " + file);
                Debug.WriteLine(src);
                context.AddSource(file, SourceText.From(src, Encoding.UTF8));
            }
        //}
        //catch (Exception ex)
        //{
        //    context.AddSource("Error.cs", SourceText.From("/*** ERROR: " + ex.Message + " ***/", Encoding.ASCII));
        //    throw;
        //}
        //context.AddSource("Log.cs", SourceText.From("/*** \r\n" + log.ToString() + "\r\n***/", Encoding.ASCII));
    }
}